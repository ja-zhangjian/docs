# ES6
## let
1. 变量不能重复声明
2. 块级作用域（全局，函数，eval）
3. 不存在变量提升
4. 不影响作用域链
PS：就是设计var的各种问题，现在来修正。。。。。。
## const
定义常量，值不能修改的量称为常量

1. 声明和赋值同时
2. 潜规则，常量大写
3. 常量不能修改
4. 块级作用域
5. 对于数据和对象的元素修改，不算是对常量的修改。（引用类型的地址）
## 变量的解构赋值
1. 数组的解构
2. 对象的解构
## 模板字符串
\`字符串`

1. 内容出现换行符
2. 拼接${}
## 简化对象写法
对象加强写法，在大括号内，同名属性和方法可以省略
~~~js
name,
run,
improve(){},
improve：function(){},//等价于上面的
~~~
## 箭头函数
=>省略function

1. this是静态，指向函数声明时所在作用域下的this的值，call不动，改不了，老牛了
2. 不能作构造实例化对象
3. 不能使用arguments变量，这个都不能用。。。。。
4. 简写，一个参数时，小括号；代码体就一句话时候，return也得省，花括号
5. 函数参数的默认值add(a,b,c=10)
## rest参数
获取函数的实参，代替arguments=>对象

...args=>数据，必须放在参数最后
## spread扩展运算符
[...]，调用的时候

数组克隆，里面要是有引用类型，也是浅拷贝

伪数组转真数组...，这个感觉和Array.form类似
## Symbol
1. 值唯一
2. 不能与其他数据运算
3. 定义的对象属性不能for...in，可以用 Reflect.ownKeys
4. USONB you are so niubility
~~~js
u undefined
s string symbol
o object
n null number
b boolean
~~~
5. Symbol内置值
## 迭代器
1. 提供for...of消费的接口
2. for..in是键名，for..of是键值
3. 创建一个指针对象，指向数据结构的起始位置，每次调用都返回一个value和done
4. 自定义遍历数据
## 生成器
## Promise
## Set
## Map
## class类
## 数值扩展
## 对象扩展
## 模块化
## 

