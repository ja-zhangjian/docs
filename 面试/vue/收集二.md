# 收集二 vue组件

:::tip 1、vue组件的分类

1. 在vue中v-router所产生的每个页面本质上来说就是一个个组件，每个组件主要承载了当前页面的样式和结构，其中也会包含一些数据处理，可视化和获取。整个页面的信息内容相对来说较大。而且数据的传递仅仅就是一些简单的父子组件的信息较为少，而且复用性十分的差。

在实际开发中，项目中的页面大多都是这样的，开发者根据业务的需求，多人协同开发。每个开发者根据分配到的任务，去实现各自的功能，每个路由相对来说依赖性较小

2. 独立组件，插件（swapper，element）。在实际开发过程中，我们常需要一些插件，提供了便捷，减少不必要的问题和开发成本

3. 业务组件，这一类组件和独立组件相似。业务组件类似在独立组件的基础上加装了业务逻辑，比如说请求数组的方式，根据业务的数据格式处理数据等，这种组件只能在当前业务中才可以使用 

:::
:::tip 2、组件的三要素prop event slot

1. prop属性：定义了组件有哪些可以配置的属性，其中组件的核心功能也是使用这个来进行配置的。写通用组件时，props最好用对象的写法，这样可以针对每个属性设置类型、默认值或自动以校验属性的值

prop传递数据是单向的，只用通过父级的修改数据才可以成功修改数据，并且还需要设置sync

``` js
< button: myProp.sync = 'ID' / >
```

2. 匿名、具名插槽

:::
:::tip 3、vue组件的内置通讯
ref给元素或者组件注册引用信息
:::
:::tip 4、provide/inject注入依赖
这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不管组件层次有多深，并在其上下游关系成立的时间里始终生效

注入依赖可以作为vuex的一个替代方案，但是官方建议，注入依赖推荐在封装组件中使用，不推荐在业务中使用，provide/inject绑定并不是可响应的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可以响应的。

虽然inject里面注入的数据不是最新的，但是需要更新的时候，可以重新异步获取

``` js
setTimeout(() => this.Data)
```

:::
:::tip 5、on与emit
emit会在当前组件实例上触发自定义事件，并且传递一些参数给监听器回调，一般来说都是父级调用on的方式来监听自定义事件
:::
:::tip 6、为什么要使用vue构造器
常规的渲染组件的方式就是，在规定的地方渲染组件，如果组件的模板是从后台发过来的，需要动态的渲染组件，如果需要实现一些提示框之类的页面，这种页面通常在他的父级body里面，而不是#app里面
:::
:::tip 7、vue.extendhe $mount的使用

``` js
//首先我们先要创建一个构造器
import Vue from 'vue'
const MyCompunt = Vue.extend({
    template: '<span>{{myText}}</span>',
    data() {
        return {
            myText: 'this is vue'
        }
    }
})
//创建构造器的实例
const myCompunt = new MyCompunt().$mount()
//我们可以指定挂载的节点
new MyCompunt().$mount('#app')
//不用$mount，直接在创建实例时指定el选项
new MyCompunt({
            el: '#app})
```

:::
:::tip 8、render函数

* 我们都知道vue核心是，虚拟DOM
* 我们通常将我们的页面的结构逻辑写在template里面，然后vue将我们的代码转换成虚拟dom
* 相比起dom，虚拟dom是通过js来处理的，所以消耗的行性能相对来说较小
* vue推荐使用template来创建html，也可以用render函数，他比template更接近编译器
* render函数的作用就是将template里面的结构转换成vnode

:::
:::tip 9、递归组件
就是组件自己调用自己

如果没有结束条件的情况直接递归的话会报错，所以针对递归组件，我们需要加上技术条件
:::
:::tip 10、vue动态添加对象类型的值
this.$set(obj, key, value)
:::
:::tip 11、vuex模块化的理解
我们按照模块化设计vuex的时候，其实vuex将每一个模块都挂载到modules上面了，然后里面挂载了设计的所有的模块
:::
